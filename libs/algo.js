// Generated by CoffeeScript 2.4.1
var solve_purp_1;

solve_purp_1 = void 0;

JS.require('JS.Set', 'JS.Hash', function(Set, Hash) {
  var Box, CallInst, Code, Instruction, MoveInst, imm_reachable_tiles, order_domino, pathfind_to_finish;
  // [y1, x1, y2, x2], y1 <= y2 and x1 <= x2
  order_domino = function(domino) {
    var x1, x2, y1, y2;
    [y1, x1, y2, x2] = domino;
    if (y1 > y2 || x1 > x2) {
      return [y2, x2, y1, x1];
    } else {
      return domino;
    }
  };
  
  // Y always comes before X for historical reasons
  Box = class Box {
    
    // min_coords and max_coords are inclusive
    // domino_routes: routes to free specific tiles and domino tiles ([y1, x1, y2, x2], y1 <= y2 and x1 <= x2)
    constructor(min_coords1, max_coords1, omino_routes1) {
      this.min_coords = min_coords1;
      this.max_coords = max_coords1;
      this.omino_routes = omino_routes1;
      if (!(this.omino_routes instanceof Hash)) {
        this.omino_routes = new Hash();
      }
    }

    static free_box(state, imm_reach) {
      var dir, dirs, i, iter_dir, j, k, l, m, max_coords, min_coords, n, num_tiles, o, old_tile, omino_routes, p, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, start, tile, tiles, x, y;
      min_coords = [state.y, state.x];
      max_coords = [state.y, state.x];
      dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
      while (dirs.length !== 0) {
        dir = dirs.shift();
        
        // Attempt to expand the box in this direction
        start = (function() {
          var k, results;
          results = [];
          for (i = k = 0; k < 2; i = ++k) {
            results.push(dir[i] > 0 ? max_coords[i] + 1 : dir[i] === 0 ? min_coords[i] : min_coords[i] - 1);
          }
          return results;
        })();
        iter_dir = dir[0] === 0 ? [1, 0] : [0, 1];
        num_tiles = dir[0] === 0 ? max_coords[0] - min_coords[0] + 1 : max_coords[1] - min_coords[1] + 1;
        tiles = (function() {
          var k, ref, results;
          results = [];
          for (i = k = 0, ref = num_tiles; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
            results.push((function() {
              var l, results1;
              results1 = [];
              for (j = l = 0; l < 2; j = ++l) {
                results1.push(start[j] + iter_dir[j] * i);
              }
              return results1;
            })());
          }
          return results;
        })();
        if (_.all(tiles, function(tile) {
          return imm_reach.hasKey(tile);
        })) {
          // Success; expand the box
          if (dir[0] < 0 || dir[1] < 0) {
            min_coords = (function() {
              var k, results;
              results = [];
              for (i = k = 0; k < 2; i = ++k) {
                results.push(min_coords[i] + dir[i]);
              }
              return results;
            })();
          } else {
            max_coords = (function() {
              var k, results;
              results = [];
              for (i = k = 0; k < 2; i = ++k) {
                results.push(max_coords[i] + dir[i]);
              }
              return results;
            })();
          }
          dirs.push(dir);
        }
      }
      omino_routes = new Hash();

// Individual tiles
      for (y = k = ref = min_coords[0], ref1 = max_coords[0]; (ref <= ref1 ? k <= ref1 : k >= ref1); y = ref <= ref1 ? ++k : --k) {
        for (x = l = ref2 = min_coords[1], ref3 = max_coords[1]; (ref2 <= ref3 ? l <= ref3 : l >= ref3); x = ref2 <= ref3 ? ++l : --l) {
          tile = [y, x];
          if (y === state.y && x === state.x) {
            omino_routes.put(tile, new Code([])); // needs no movement
          } else {
            old_tile = imm_reach.get(tile);
            dir = [tile[0] - old_tile[0], tile[1] - old_tile[1]];
            omino_routes.put(tile, new Code([new CallInst(imm_reach.get(tile)), MoveInst.purpless(dir)]));
          }
        }
      }

// Vertical dominoes
      for (y = m = ref4 = min_coords[0], ref5 = max_coords[0] - 1; (ref4 <= ref5 ? m <= ref5 : m >= ref5); y = ref4 <= ref5 ? ++m : --m) {
        for (x = n = ref6 = min_coords[1], ref7 = max_coords[1]; (ref6 <= ref7 ? n <= ref7 : n >= ref7); x = ref6 <= ref7 ? ++n : --n) {
          omino_routes.put([y, x, y + 1, x], new Code([new CallInst([y, x])]));
        }
      }

// Horizontal dominoes
      for (y = o = ref8 = min_coords[0], ref9 = max_coords[0]; (ref8 <= ref9 ? o <= ref9 : o >= ref9); y = ref8 <= ref9 ? ++o : --o) {
        for (x = p = ref10 = min_coords[1], ref11 = max_coords[1] - 1; (ref10 <= ref11 ? p <= ref11 : p >= ref11); x = ref10 <= ref11 ? ++p : --p) {
          omino_routes.put([y, x, y, x + 1], new Code([new CallInst([y, x])]));
        }
      }
      return new Box(min_coords, max_coords, omino_routes);
    }

    
    // After freeing a domino, the player should be at the top left of the domino
    expand(state) {
      var back_domino, blocked, dir, dirs, dirset, domino, forth_domino, free_indexes, free_propogation, helper_tile, i, index, inner_domino, insts, iter_dir, j, k, l, len, len1, m, n, neg_dir, neg_iter_dir, new_dir, new_insts, num_back, num_forth, num_tiles, outer_domino, ref, ref1, ref2, start, step, tile, tile_back_in, tile_back_out, tile_forth_in, tile_forth_out, tiles;
      dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]];
      dirset = new Set(dirs); // to keep track of which directions are already on the to-process list
      while (dirs.length !== 0) {
        dir = dirs.shift();
        dirset.remove(dir);
        start = (function() {
          var k, results;
          results = [];
          for (i = k = 0; k < 2; i = ++k) {
            results.push(dir[i] > 0 ? this.max_coords[i] + 1 : dir[i] === 0 ? this.min_coords[i] : this.min_coords[i] - 1);
          }
          return results;
        }).call(this);
        iter_dir = dir[0] === 0 ? [1, 0] : [0, 1];
        num_tiles = dir[0] === 0 ? this.max_coords[0] - this.min_coords[0] + 1 : this.max_coords[1] - this.min_coords[1] + 1;
        tiles = (function() {
          var k, ref, results;
          results = [];
          for (i = k = 0, ref = num_tiles; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
            results.push((function() {
              var l, results1;
              results1 = [];
              for (j = l = 0; l < 2; j = ++l) {
                results1.push(start[j] + iter_dir[j] * i);
              }
              return results1;
            })());
          }
          return results;
        })();
        free_indexes = (function() {
          var k, ref, results;
          results = [];
          for (i = k = 0, ref = num_tiles; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
            if (game_is_tile_free(state, tiles[i][0], tiles[i][1])) {
              results.push(i);
            }
          }
          return results;
        })();
        for (i = k = 0, len = free_indexes.length; k < len; i = ++k) {
          index = free_indexes[i];
          tile = tiles[index];
          
          // Show how to free a domino containing this tile
          helper_tile = [tile[0] - dir[0], tile[1] - dir[1]];
          domino = order_domino([tile[0], tile[1], helper_tile[0], helper_tile[1]]);
          insts = [new CallInst(helper_tile)];
          
          // Idiosyncracies :(
          if (dir[0] < 0 || dir[1] < 0) {
            insts.push(MoveInst.purpless(dir));
          }
          this.omino_routes.put(domino, new Code(insts));
          
          // Show how to free this tile
          insts = [new CallInst(domino)];
          // More idiosyncracies :(
          if (dir[0] > 0 || dir[1] > 0) {
            insts.push(MoveInst.purpless(dir));
          }
          this.omino_routes.put(tile, new Code(insts));
          if (game_tile_at(state, tile[0], tile[1]) === TILE_FINISH) {
            return;
          }
          
          // Now show it for nearby tiles
          num_back = index - (i > 0 ? Math.floor((index + free_indexes[i - 1]) / 2) : 0);
          num_forth = (i < free_indexes.length - 1 ? Math.floor((index + free_indexes[i + 1]) / 2) : tiles.length - 1) - index;
          neg_dir = [-dir[0], -dir[1]];
          neg_iter_dir = [-iter_dir[0], -iter_dir[1]];
          
          // Going backward
          free_propogation = [];
          for (step = l = 0, ref = num_back; (0 <= ref ? l < ref : l > ref); step = 0 <= ref ? ++l : --l) {
            tile_forth_out = (function() {
              var m, results;
              results = [];
              for (j = m = 0; m < 2; j = ++m) {
                results.push(tile[j] - iter_dir[j] * step);
              }
              return results;
            })();
            tile_forth_in = (function() {
              var m, results;
              results = [];
              for (j = m = 0; m < 2; j = ++m) {
                results.push(helper_tile[j] - iter_dir[j] * step);
              }
              return results;
            })();
            tile_back_out = (function() {
              var m, results;
              results = [];
              for (j = m = 0; m < 2; j = ++m) {
                results.push(tile[j] - iter_dir[j] * (step + 1));
              }
              return results;
            })();
            tile_back_in = (function() {
              var m, results;
              results = [];
              for (j = m = 0; m < 2; j = ++m) {
                results.push(helper_tile[j] - iter_dir[j] * (step + 1));
              }
              return results;
            })();
            inner_domino = order_domino([tile_back_in[0], tile_back_in[1], tile_forth_in[0], tile_forth_in[1]]);
            blocked = game_tile_at(state, tile_back_out[0], tile_back_out[1]) === TILE_BLOCK;
            
            // outer domino
            outer_domino = order_domino([tile_back_out[0], tile_back_out[1], tile_forth_out[0], tile_forth_out[1]]);
            insts = [].concat(...free_propogation);
            insts.push(new CallInst(inner_domino), MoveInst.purpless(iter_dir), MoveInst.purpless(dir), new MoveInst(neg_dir, blocked ? neg_iter_dir : null), MoveInst.purpless(dir), MoveInst.purpless(neg_iter_dir));
            this.omino_routes.put(outer_domino, new Code(insts));
            if (step !== num_back - 1 || i === 0) {
              // back domino
              back_domino = order_domino([tile_back_in[0], tile_back_in[1], tile_back_out[0], tile_back_out[1]]);
              insts = [].concat(...free_propogation); // propogating the free tile
              new_insts = [
                new CallInst(inner_domino),
                new MoveInst(iter_dir,
                blocked ? dir : null),
                MoveInst.purpless(neg_iter_dir) // propogating free tile an extra space
              ];
              free_propogation.push(...new_insts);
              free_propogation.push(CallInst.reversed(inner_domino));
              insts.push(...new_insts);
              if (dir[0] < 0 || dir[1] < 0) {
                insts.push(MoveInst.purpless(dir));
              }
              this.omino_routes.put(back_domino, new Code(insts));
              insts = [new CallInst(back_domino)];
              if (dir[0] > 0 || dir[1] > 0) {
                insts.push(MoveInst.purpless(dir));
              }
              this.omino_routes.put(tile_back_out, new Code(insts));
              if (game_tile_at(state, tile_back_out[0], tile_back_out[1]) === TILE_FINISH) {
                return;
              }
            }
          }
          
          // Going forward (slight idiosyncratic changes)
          free_propogation = [];
          for (step = m = 0, ref1 = num_forth; (0 <= ref1 ? m < ref1 : m > ref1); step = 0 <= ref1 ? ++m : --m) {
            tile_back_out = (function() {
              var n, results;
              results = [];
              for (j = n = 0; n < 2; j = ++n) {
                results.push(tile[j] + iter_dir[j] * step);
              }
              return results;
            })();
            tile_back_in = (function() {
              var n, results;
              results = [];
              for (j = n = 0; n < 2; j = ++n) {
                results.push(helper_tile[j] + iter_dir[j] * step);
              }
              return results;
            })();
            tile_forth_out = (function() {
              var n, results;
              results = [];
              for (j = n = 0; n < 2; j = ++n) {
                results.push(tile[j] + iter_dir[j] * (step + 1));
              }
              return results;
            })();
            tile_forth_in = (function() {
              var n, results;
              results = [];
              for (j = n = 0; n < 2; j = ++n) {
                results.push(helper_tile[j] + iter_dir[j] * (step + 1));
              }
              return results;
            })();
            inner_domino = order_domino([tile_back_in[0], tile_back_in[1], tile_forth_in[0], tile_forth_in[1]]);
            blocked = game_tile_at(state, tile_forth_out[0], tile_forth_out[1]) === TILE_BLOCK;
            
            // outer domino
            outer_domino = order_domino([tile_back_out[0], tile_back_out[1], tile_forth_out[0], tile_forth_out[1]]);
            insts = [].concat(...free_propogation);
            insts.push(new CallInst(inner_domino), MoveInst.purpless(dir), new MoveInst(neg_dir, blocked ? iter_dir : null), MoveInst.purpless(dir));
            this.omino_routes.put(outer_domino, new Code(insts));
            
            // forth domino
            forth_domino = order_domino([tile_forth_in[0], tile_forth_in[1], tile_forth_out[0], tile_forth_out[1]]);
            insts = [].concat(...free_propogation); // propogating the free tile
            new_insts = [
              new CallInst(inner_domino),
              MoveInst.purpless(iter_dir),
              new MoveInst(neg_iter_dir,
              blocked ? dir : null) // propogating free tile an extra space
            ];
            free_propogation.push(...new_insts);
            free_propogation.push(CallInst.reversed(inner_domino));
            insts.push(...new_insts);
            insts.push(MoveInst.purpless(iter_dir));
            if (dir[0] < 0 || dir[1] < 0) {
              insts.push(MoveInst.purpless(dir));
            }
            this.omino_routes.put(forth_domino, new Code(insts));
            insts = [new CallInst(forth_domino)];
            if (dir[0] > 0 || dir[1] > 0) {
              insts.push(MoveInst.purpless(dir));
            }
            this.omino_routes.put(tile_forth_out, new Code(insts));
            if (game_tile_at(state, tile_forth_out[0], tile_forth_out[1]) === TILE_FINISH) {
              return;
            }
          }
        }
        if (free_indexes.length !== 0) {
          // Success; expand the box
          if (dir[0] < 0 || dir[1] < 0) {
            this.min_coords = (function() {
              var n, results;
              results = [];
              for (i = n = 0; n < 2; i = ++n) {
                results.push(this.min_coords[i] + dir[i]);
              }
              return results;
            }).call(this);
          } else {
            this.max_coords = (function() {
              var n, results;
              results = [];
              for (i = n = 0; n < 2; i = ++n) {
                results.push(this.max_coords[i] + dir[i]);
              }
              return results;
            }).call(this);
          }
          ref2 = [[1, 0], [0, 1], [-1, 0], [0, -1]];
          for (n = 0, len1 = ref2.length; n < len1; n++) {
            new_dir = ref2[n];
            // Expanding successful; should check this direction and 90-degree-off directions
            if ((new_dir[0] !== -dir[0] || new_dir[1] !== -dir[1]) && !dirset.contains(new_dir)) {
              dirs.push(new_dir);
              dirset.add(new_dir);
            }
          }
        }
      }
    }

  };
  
  //reachable_tiles: (state) ->
  Instruction = class Instruction {};
  MoveInst = class MoveInst extends Instruction {
    
    // Purp offset of null = no purping
    constructor(dir1, purp_offset) {
      super();
      this.dir = dir1;
      this.purp_offset = purp_offset;
    }

    static purpless(dir) {
      return new MoveInst(dir, null);
    }

    unfolded(state, omino_routes, reversed) {
      var i;
      return [
        //console.log @dir, @purp_offset, reversed
        new MoveInst((function() {
          var k,
        results;
          results = [];
          for (i = k = 0; k < 2; i = ++k) {
            results.push(reversed ? -this.dir[i] : this.dir[i]);
          }
          return results;
        }).call(this),
        this.purp_offset)
      ];
    }

    is_opposite(other) {
      return this.dir[0] === -other.dir[0] && this.dir[1] === -other.dir[1] && (((this.purp_offset == null) && (other.purp_offset == null)) || ((this.purp_offset != null) && (other.purp_offset != null) && this.purp_offset[0] === other.purp_offset[0] && this.purp_offset[1] === other.purp_offset[1]));
    }

  };
  CallInst = class CallInst extends Instruction {
    constructor(omino1, reversed1) {
      super();
      this.omino = omino1;
      this.reversed = reversed1;
      if (this.reversed == null) {
        this.reversed = false;
      }
    }

    static reversed(omino) {
      return new CallInst(omino, true);
    }

    unfolded(state, omino_routes, reversed) {
      var ret;
      //console.log @omino, reversed != @reversed, 'Begin'
      ret = omino_routes.get(this.omino).unfolded(state, omino_routes, reversed !== this.reversed).insts;
      //console.log @omino, reversed != @reversed, 'End'
      return ret;
    }

  };
  Code = class Code {
    constructor(insts1) {
      this.insts = insts1;
      if (this.insts == null) {
        this.insts = [];
      }
    }

    unfolded(state, omino_routes, reversed) {
      var inst, inst_id, insts, k, len, ref;
      if (reversed == null) {
        reversed = false;
      }
      inst_id = reversed ? this.insts.length - 1 : 0;
      insts = [];
      while ((reversed ? inst_id >= 0 : inst_id < this.insts.length)) {
        ref = this.insts[inst_id].unfolded(state, omino_routes, reversed);
        for (k = 0, len = ref.length; k < len; k++) {
          inst = ref[k];
          if (insts.length > 0 && inst.is_opposite(insts[insts.length - 1])) {
            insts.pop();
          } else {
            insts.push(inst);
          }
        }
        inst_id += reversed ? -1 : 1;
      }
      return new Code(insts);
    }

    
    // assumes unfolded
    execute(state, gif) {
      var code, func, inst_id;
      code = this;
      inst_id = 0;
      func = function() {
        var inst;
        inst = code.insts[inst_id];
        game_move(state, false, inst.purp_offset != null, inst.purp_offset, inst.dir[0], inst.dir[1]);
        ui_redraw(state, gif);
        inst_id += 1;
        if (inst_id < code.insts.length) {
          return setTimeout(func, 200);
        }
      };
      if (this.insts.length !== 0) {
        return func();
      }
    }

  };
  
  // Returns a hashed map of tiles reachable without purping a block, mapping them to previous tile
  imm_reachable_tiles = function(state) {
    var dir, k, len, map, new_tile, ref, tile, to_expand;
    to_expand = [[state.y, state.x]];
    map = new Hash([[state.y, state.x], null]);
    while (to_expand.length !== 0) {
      tile = to_expand.shift();
      ref = [[1, 0], [0, 1], [-1, 0], [0, -1]];
      for (k = 0, len = ref.length; k < len; k++) {
        dir = ref[k];
        new_tile = [tile[0] + dir[0], tile[1] + dir[1]];
        if (game_is_tile_free(state, new_tile[0], new_tile[1]) && !map.hasKey(new_tile)) {
          map.put(new_tile, tile);
          to_expand.push(new_tile);
          
          // Early out
          if (game_tile_at(state, new_tile[0], new_tile[1]) === TILE_FINISH) {
            return map;
          }
        }
      }
    }
    return map;
  };
  
  // Takes the penguin to the finish given a breadth-first-search result and the finish tile
  pathfind_to_finish = function(state, imm_reach, finish_tile) {
    var code, dir, insts, old_tile, tile;
    insts = [];
    tile = finish_tile;
    while (imm_reach.get(tile) != null) {
      old_tile = imm_reach.get(tile);
      dir = [tile[0] - old_tile[0], tile[1] - old_tile[1]];
      insts.push(MoveInst.purpless(dir));
      tile = old_tile;
    }
    insts.reverse();
    code = new Code(insts);
    return code.execute(state);
  };
  return solve_purp_1 = function(state, gif) {
    var box, finish_tile, imm_reach;
    $('impossible').innerHTML = '';
    imm_reach = imm_reachable_tiles(state);
    finish_tile = game_finish_tile(state);
    if (imm_reach.hasKey(finish_tile)) {
      pathfind_to_finish(state, imm_reach, finish_tile);
      return true;
    }
    box = Box.free_box(state, imm_reach);
    box.expand(state);
    //console.log(box)
    if (box.omino_routes.hasKey(finish_tile)) {
      $('impossible').innerHTML = "Possible!";
      box.omino_routes.get(finish_tile).unfolded(state, box.omino_routes).execute(state, gif);
      return true;
    }
    $('impossible').innerHTML = "Impossible!";
    return false;
  };
});
